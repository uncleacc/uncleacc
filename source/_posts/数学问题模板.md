---
title: 数学问题模板
author: uncleacc
avatar: >-
  https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3616765171,3721318254&fm=26&gp=0.jpg
authorLink: www.fezhu.top
authorAbout: 一个好奇的人
authorDesc: 一个好奇的人
categories: 记录
comments: true
date: 2020-04-28 09:46:42
tags: 数学问题记录
keywords:
description:
photos: https://cdn.jsdelivr.net/gh/uncleacc/Img/textbg/32.webp
---
# 筛选质因子
```
  for(int i=2;i*i<=k;i++){
      if(k%i==0){
          p[++tail]=i;  //p就是储存质因子的数组
          while(k%i==0) k/=i;  //把k中所有i的质因子全部除去
      }
	}
    if(k>1) p[++tail]=k;
```
# 容斥原理
前言：
1. 计算1-n中m的的倍数的数量时，直接n/m
2. 容斥原理是在互质的数的基础上实现的
公式：

(A+B+C+D+E……)-(A*B+A*C+A*D……+B*C+B*D)+(A*B*C+B*C*D……)-(A*B*C*D+B*C*D*E……)……

规律： 奇数相加，偶数相减

代码：
```
    p数组储存的是筛选的质因子
    long long fun(long long x){
        long long res=0;  //res储存的是1-x中与K不互质的数量 
        for(int i=1;i<(1<<tail);i++){  //这里的1<<tail是指2的tail次方，表示tail个质因子有多少种组合情况 
            long long cur=1,cnt=0;  //cur表示在当前选中的质因子中的乘积，cnt表示当前选中的数量是奇数还是偶数 
            for(int j=0;j<tail;j++){  //这个循环是枚举tail的二进制形式 
                if((i>>j)&1){  //这个是判断i的第j位是不是1，如果是则表示选中第j个数 
                    cnt++;  //表示选中了几个数，每选中一个就加一 
                    cur*=p[j+1];  //选中第j个数就用cur乘以第j个质因子数，注意质因子数组是从1开始的，所以要加一 
                }
            }
            if(cnt&1) res+=x/cur;  //如果cnt是偶数就相加 
            else res-=x/cur;  //奇数就相减 
        }
        return x-res;  //res储存的是1-x中与K不互质的数量，所以要用x-res得到互质的数量 
    }
```
# 欧拉筛
```
int vis[maxn],p[maxn/10]; //质数密度不大，除以10可以减少空间浪费
int cnt=0;
void prime()
{
    vis[1]=1;
    for(int i=2;i<=maxn;i++){
        if(!vis[i]) p[++cnt]=i;
        for(int j=1;j<=cnt&&i<=maxn/p[j];j++){
            vis[i*p[j]]=1;
            if(i%p[j]==0) break; //核心代码，如果i能整除这个质数则跳出循环
        }
    }
}
```
# 埃式筛
```
int p[1000]; //p数组用来存储质数
void prime()
{
    vis[1]=1; //1不是质数
    for(int i=2;i<=n;i++){ //n是筛选的范围
        if(!vis[i]){
            p[++cnt]=i; //存储质数
            for(int j=2*i;j<=n;j+=i){  //这里可以有一个优化，j=2*i
                vis[j]=1; //标记质数的倍数
            }
        }
    }
}
```
# 数学公式
* 海伦公式
S=sqrt(p * (p-a) * (p-b) * (p-c))
# 快速幂
<font color="red">
非递归版本
</font>

```
int p(int a,int b){
  int t,y;
  t=1; y=a;
  while (b!=0){
    if (b&1==1) t=t*y;
    y=y*y;
    b=b>>1;
  }
  return t;
}
```
<font color="red">
递归版本
</font>

```
ll pow(ll a,ll i){
  if (i==0) return 1;
  int temp=pow(a,i>>1);
  temp=temp*temp%MOD;
  if (i&1) temp=(ll)temp*a%MOD;
  return temp%MOD;
}
```
# 树状数组模板
```
int lowbit(int n){
    return n&-n;
}

void add(int x,int y,int n){
    for(int i=x;i<=n;i+=lowbit(i))
        c[i] += y;
}

int getsum(int x){
    int ans = 0;
    for(int i=x;i;i-=lowbit(i))
        ans += c[i];
    return ans;
}
```
# 查并集
```
void init(int n) {
    for(int i = 1; i <= n; i++) {
        f[i] = i;
    }
}

int getFriend(int v) {  
    if(f[v] == v) {
        return v;
    }
    return f[v] = getFriend(f[v]);
}

void merge(int a, int b) {
    int t1 = getFriend(a);
    int t2 = getFriend(b);
    if(t1 != t2) {  
        f[t2] = t1;
    }
}
```
>持续更新中……
